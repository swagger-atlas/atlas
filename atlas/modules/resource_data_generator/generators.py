import importlib
import os

from atlas.modules import exceptions, mixins
from atlas.modules.helpers.resource_map import ResourceMapResolver
from atlas.modules.resource_data_generator import constants as resource_constants
from atlas.modules.resource_data_generator.database import client as db_client
from atlas.conf import settings


class ProfileResourceDataGenerator(mixins.ProfileMixin):
    """
    1. Reads Resource Mapping file
    2. If required, Generates data for each resource in resource mapping for each profile
    3. Create a separate output file for each Profile, and save data for all resources there
    """

    def __init__(self, profiles=None):

        super().__init__()
        self.resource_map_resolver = ResourceMapResolver()
        self.client = db_client.Client()

        self.profiles = profiles or []
        self.active_profile_config = None

    def read_for_profile(self, resources):
        """
        Get all resource data for specific Profile

        Two major responsibilities of this function are:
            - Check if we need to fetch data for the resource. If yes, call parse_for_resource fxn, else continue
            - Check if the resource could be updated at run_time.
                For all resources which could not be updated at run time, add them in settings
        """

        not_run_time_update_resources = set()

        for resource, config in self.resource_map_resolver.resource_map.items():
            # We have already constructed this resource, so ignore this and move
            if resource in resources:
                continue

            # Someone else is fetching this resource, so no need to do it again
            if resource in self.resource_map_resolver.alias_map:
                continue

            if resource == resource_constants.GLOBALS:
                continue

            config = self.resource_map_resolver.resource_config[resource]

            update_at_run_time = config.get(resource_constants.RESOURCE_UPDATE_RUN_TIME, True)
            if not update_at_run_time:
                not_run_time_update_resources.add(resource)

            resources[resource] = set(self.parse_for_resource(resource, config))

        setattr(settings, "NOT_UPDATE_RUN_TIME_RESOURCES", not_run_time_update_resources)

    def parse_for_resource(self, resource: str, config: dict):
        """
        Get the resource data for a single resource
        """

        dummy_resource = config.get(resource_constants.DUMMY_DEF)

        # Dummy resources are auto-generated by program.
        # It is expected that they would get their data through Automated Workflow
        # And so we do not need to fetch their data at this point
        if dummy_resource:
            result = []
        else:
            source = config.get(resource_constants.SOURCE, resource_constants.DB_TABLE)

            if source == resource_constants.DB_TABLE:
                result = self.parse_db_source(config, self.resource_map_resolver.globals)
            elif source == resource_constants.SCRIPT:
                result = self.parse_python_source(config)
            else:
                raise exceptions.ResourcesException(f"Incorrect source defined for {resource}")

            if not isinstance(result, (list, tuple, set)):
                raise exceptions.ResourcesException(f"Result for {resource} must be Built-in iterable")

        return result

    def parse(self):
        """
        Entry point for class
        """

        # Before fetching data for resources,
        # we would like to read the Resource mapping and resolve it as simply as we could
        self.resource_map_resolver.resolve_resources()
        resource_sub_folder = os.path.join(settings.OUTPUT_FOLDER, settings.RESOURCES_FOLDER)

        for name, config in self.get_profiles().items():
            resources = {}
            self.active_profile_config = config
            self.read_for_profile(resources)
            resource_file_name = self.get_profile_resource_name(name, config)

            existing_resources = self.read_file(resource_file_name, {}, resource_sub_folder)
            resources = {**existing_resources, **resources}     # We want to over-write existing resource with resources

            self.write_file(resource_file_name, resources, resource_sub_folder, False, force_write=True)

    @staticmethod
    def construct_fetch_query(table, column, filters):
        """
        Construct a simple SQL Fetch Query
        """
        select_statement = f"select {column} from {table}"
        filter_statement = f"where {filters}" if filters else ""
        limit_statement = f"limit {resource_constants.LIMIT}"

        return f"{select_statement} {filter_statement} {limit_statement};"

    def parse_db_source(self, config, global_settings):

        # First check if raw SQL is provided
        sql = config.get(resource_constants.SQL)
        mapper = config.get(resource_constants.MAPPER, global_settings.get(resource_constants.MAPPER))

        client_func = self.client.fetch_rows

        func = None
        if mapper:
            func = self.get_function_from_mapping_file(mapper)

        if not sql:
            # If Raw SQL is not provided, then we need to construct query
            sql = self.construct_query(config, global_settings)
            client_func = self.client.fetch_ids

        # Query should be formatted according to Profile configuration
        return client_func(sql=sql.format(**self.active_profile_config), mapper=func)

    def construct_query(self, config, global_settings):
        table = config.get(resource_constants.TABLE, global_settings.get(resource_constants.TABLE))

        if not table:
            raise exceptions.ResourcesException(f"Table not defined for {config}")

        column = config.get(resource_constants.COLUMN, resource_constants.DEFAULT_COLUMN)
        filters = config.get(resource_constants.FILTERS, global_settings.get(resource_constants.FILTERS))

        return self.construct_fetch_query(table, column, filters)

    @staticmethod
    def get_function_from_mapping_file(func_name):
        map_hook_file = f"{settings.INPUT_FOLDER}.{settings.RES_MAPPING_HOOKS_FILE}"[:-len(".py")]

        try:
            func = getattr(importlib.import_module(map_hook_file), func_name)
        except AttributeError:
            raise exceptions.ResourcesException(f"Function {func_name} not defined in Map Hooks File")

        return func

    def parse_python_source(self, config):

        func_name = config.get(resource_constants.FUNCTION)

        if not func_name:
            raise exceptions.ResourcesException(f"Function must be declared for {config}")

        func = self.get_function_from_mapping_file(func_name)

        args = config.get(resource_constants.ARGS, ())

        if not isinstance(args, (tuple, list)):
            raise exceptions.ResourcesException(f"Function {func_name} Args should be tuple/list")

        kwargs = config.get(resource_constants.KWARGS, {})

        if not isinstance(kwargs, dict):
            raise exceptions.ResourcesException(f"Function {func_name} Keyword Args should be dict")

        return func(*args, **kwargs)

    def get_profiles(self):
        profiles = self.read_file_from_input(settings.PROFILES_FILE, {})

        if self.profiles:
            profile_to_read = set(self.profiles)
            profiles = {key: val for key, val in profiles.items() if key in profile_to_read}

        return profiles
