Hooks
=====

(This is documentation for run time hooks for profiles are request.
If you are looking for Resource Mapping Hooks, visit [Resources](docs/resources.md) page)

Hooks basically let you inject custom code at various places during Load Testing.

Different types of Hooks are:
1. Profile Selection Hooks
2. Profile Setup Hooks
3. Request Body Hooks

After defining hooks, you should export them via `hookRegister`


Profile Selection Hooks
-----------------------
They are functions which you can write to filter out which profiles you want to select.
Currently, the convention is to randomly pick one profile from list of all profiles

Example of this type of hook:

```js
function filterByID(profiles) {
    return _.filter(profiles, function (profile) { profile.id < 10; });
}
```

Things to note:
- It must take profiles and return profiles array
- Its hookRegister ID is "$profileSelection"
- This is the first thing to be called by load test runner


Profile Setup Hooks
-------------------
These are used to setup relevant data once the profile is selected.

Example:
```js
async function addHeaders(profile) {
    profile.auth = {
        "headers": {'Authorization': 'Token ' + profile.token}
    };
    return profile;
}
```

Things to note:
- It must take single profile object and returns profile (as part of promise contract)
- Its hookRegister ID is "$profileSetup"
- There must be at least one profile setup hook present
- This is the final stage of setup for load test runner.
  Load test runner does not go ahead till this hook returns a valid promise


Request Hooks
-----
These could be used to manipulate request parameters before sending request.
With this, for example, you can manipulate URL, request body etc

Example:
```js
function removeUserField(...args) {
    let body = args[1];
    del body.user;
    args[1] = body;
    return args;
}
```

Things to note:
- Each hook thus defined must take ...args and must return args.
- Number and order of arguments in return must not change
- For requests which support body (eg: POST/PUT/PATCH), args are in order: URL, BODY, REQUEST PARAMS
- For requests which do NOT support body (eg: GET), args are in order: URL, REQUEST PARAMS
- Relevant HookRegister ID is Swagger OP_KEY for the request. (Swagger OP_KEY is "METHOD url")
- This is called just before request is sent to Server.
  This means that it is called _after_ ATLAS fills the request body, headers and other params by itself.
  This has two implications:
  - You have access to all data which is provided by ATLAS, so you only need to change only what you need.
  - If there is an error during ATLAS trying to fill the data, that API request will fail before it reaches the hook


#### File Hooks

In the request hooks, we have a out-of-box solution for adding files to fields.

```js
file = require("./libs/files").file;

function addCSVFile(...args) {
    let body = args[1];
    body.upload_file = file.getCSVFile();
    args[1] = body;
    return args;
}
```

You can use following File Methods:
- `getImageFile()`
- `getCSVFile()`
- `getExcelFile()`
- `getTextFile()`
- `getFileByPath(path)` (In this, supply your own file by providing path)

**CAVEAT** : Make sure that the file fields is marked as type `file` in Swagger.
If not, it may result in unexpected behaviour.
When ATLAS finds `file` type fields, it automatically generates dummy text file for same


Hook Registration
-----------------

Once you define functions, you must register them via HookRegister.

For example, for above snippets,

```js
exports.hookRegister = [
    ["$profileSelection", filterByID],
    ["$profileSetup", addHeaders],
    ["PUT /dummy/path/{some_id}", removeUserField]
];
```


`hookRegister` is a list which contains all registries.
Each registry in itself is a 2-element list:
1. First element contains the OP_KEY. For Swagger Operation, OP_KEY is defined as "METHOD url"
You can also see all OP_KEYS in `conf/routes.py` which is generated by running `atlas generate_routes`
2. Second Element is hook function name

You can associate multiple hooks to a single operation.
In the case, hooks would be run in the order as they are defined in hookRegister.


Hook Chaining
-------------

This illustrates how a single operation can have multiple hooks associated with it


```js
function filterByID(profiles) {
    return _.filter(profiles, function (profile) { profile.id < 10; });
}

function selectiveWeight(profiles) {
    // Profile with frequency "heavy" to be weighed twice as much as others.
    let newProfiles = profiles;
    _.forEach(profiles, function(profile) {
        if (profile.frequency === "heavy") {
            newProfiles.push(profile);
        }
    };
    return newProfiles;
}

// In this case, first profiles would be filtered and then weighed
exports.hookRegister = [
    ["$profileSelection", filterByID],
    ["$profileSelection", selectiveWeight]
];
```
